---
title: "Project2"
author: "MATEO BANDALA-JACQUES"
date: "2024-09-12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(dplyr)
library(ggplot2)
library(here)
library(lubridate)
library(stringr)
library(ggthemes)
```

## **Part 1: Fun with functions**

## *Part 1A: Exponential transformation*

```{r 1A}


Exp <- function(x,k) {
  result <- 1
  for (n in 1:k){
    series <- ((x^n) / factorial(n))
    result <- result + series
  }
  
print(result)  
}


Exp(1,5)
Exp(2,4)



```

## *Part 1B: Sample mean and sample standard deviation*

```{r 1B}


#Function for sample mean
sample_mean <- function(numbers) {
  mean_numbers <- sum(numbers)/length(numbers)
  return(mean_numbers)
}

sample_mean(c(1,2,3,4,5,6,7))


#Function for sample SD

sample_sd <- function(numbers){
  mean_numbers <- sample_mean(numbers)  # Use the function I created above
  sum_squared_differences <- 0          #Start at 0
  
  for (i in numbers){                   #For each of the numbers
    sum_squared_differences <- sum_squared_differences + (i - mean_numbers)^2 #The number, minus the mean, squared
  }
  
  variance <- sum_squared_differences / (length(numbers)-1)        #Divided by N-1
  sd_value <- sqrt(variance)   #And square rooted
  
return(sd_value)
}
  

sample_sd(c(1,2,3,4,5)) #yay, it worked


```

## *Part 1C: Confidence Intervals*

```{r 1C}

calculate_CI <- function(numbers, conf) {
  if(conf<0 | conf >1 | !is.numeric(conf)) {stop("Alpha must be a number from 0 to 1")}
  if(!is.numeric(numbers)) {stop("Please input a vector of numbers")}
  
  
  mean_numbers <- sample_mean(numbers) # First calculate the mean
  samplesd_numbers <- sample_sd(numbers) #Then calculate the standard deviation
  
  alpha <- 1 - conf    #Alpha is 1- conf
  degrees_freedom <- length(numbers) - 1    #Get the degree of freedom 
  t_score <- qt (1 - alpha/2, degrees_freedom)     #derive the T-score
  
  standard_error <- samplesd_numbers/sqrt(length(numbers))   #Standard error
  
  margin_error <- t_score * standard_error #standard error times T-score 
  
  lower_bound <- mean_numbers - margin_error   
  upper_bound <- mean_numbers + margin_error
  
  return(c("Lower"=lower_bound, "Upper"=upper_bound))
  
}



x <- c(3,6,2,1,6,3,1,5,5)

calculate_CI(x, 0.95)



dat <- data.frame(x=x)
fit <- lm(x ~ 1, dat)
confint(fit) #yay, it matched



```




## Part 2: Data Wrangling 

```{r 2.1}

library(here)


rainfall <- readRDS(file= here("data", "tuesdata_rainfall.RDS"))
temperature <- readRDS(file= here("data", "tuesdata_temperature.RDS"))

#Start with rainfall dataset and drop any rows with NAs.
rainfall <- na.omit(rainfall)

#Create a new column titled date that combines the columns year, month, day into one column separated by “-”. (e.g. #“2020-01-01”). This column should not be a character, but should be recognized as a date. (Hint: check out the #ymd() function in lubridate R package). You will also want to add a column that just keeps the year.


rainfall$date <- make_date(rainfall$year, rainfall$month, rainfall$day)
rainfall$date[1:5]
rainfall <- rainfall %>% select(-month, -day)


#Using the city_name column, convert the city names (character strings) to all upper case.
rainfall$city_name <- toupper(rainfall$city_name)
rainfall$city_name[1:10]

#Join this wrangled rainfall dataset with the temperature dataset such that it includes only #observations that are in both data frames. (Hint: there are two keys that you will need to join #the two datasets together). (Hint: If all has gone well thus far, you should have a dataset with #83,964 rows and 13 columns).

names(rainfall)
names(temperature)

joined <- inner_join(rainfall, temperature, by=c("city_name", "date"))


```


## Part 3: Data Visualization

# 3A: Plotting temperature data overtime

```{r 3A}


joined%>%
  filter(year>=2014) %>%
  ggplot(aes(x=date, y=temperature, color=temp_type)) + 
  geom_line() +
  scale_color_manual(
    values = c("max" = "#F59B25", "min" = "#42D6ED"),
    labels = c("max" = "Maximum", "min" = "Minimum"),
    name = "Temperature type") +
  labs (x="Date", y="Temperature, celsius", title = "Temperature in Australian cities by year",
        subtitle = "Canberra has the highest variation in temperatures, while Melbourne and Perth have the least",
        caption = "Mateo Jacques") +
  facet_wrap(~ city_name) +
  theme_minimal() +
  theme(legend.position = c(0.8,0.1))



```


```{r 3B}


`%nin%` <- Negate(`%in%`)


plot_city <- function(city, year){

if(city %nin% joined$city_name) {
  print(unique(joined$city_name))
  stop("Pick a city from the provided list")}
  
if(year %nin% joined$year){
  stop("Pick a year between 1910 and 2019")
}
  
  
  plot <- joined %>%
    filter(city_name == city, year == year) %>%
    ggplot(aes(log(rainfall)))+
    geom_histogram(binwidth = 0.2, fill="#42D6ED", color="black", alpha=0.7)
    print(plot) +
    labs(x="Log of rainfall, mm", y="Count", title = paste0("Histogram of rainfall for ", str_to_title(city)),
         subtitle = "Note: X axis is in log scale", 
         caption = paste0("Plot generated on ",today())) +
      theme_stata()
  
  }

#plot_city("BALTIMORE", 2017) #Testing my 'stop'
plot_city("PERTH", 2017)


#How I designed my function:

#I create a function to negate %in% so that if the input city does not exist in the data, it stops and prints the name of options
#Same for the year
#Then I used ggplot to input a city name and the year, and created a hisrtogram.
#I also added a title that includes the input city name, and added the date as a caption using lubridae


```



## Part 4: Apply functions and plot


#4A: Tasks

``` {r 4a}

#First, filter for only years including 2014 and onwards.

joined <- joined %>%
  filter(year>=2014) %>%
  group_by(city_name, date) %>%
  slice_head() %>%
  ungroup()

#I sliced that data set because we artifically created two rows for each date when we obtained the max and min temperature.
#And Now we have one row per city per day

#For a given city and for a given year, calculate the sample mean (using your function sample_mean()), the sample standard deviation (using #your function sample_sd()), and a 95% confidence interval for the average rainfall (using your function calculate_CI()). Specifically, you #should add two columns in this summarized dataset: a column titled lower_bound and a column titled upper_bound containing the lower and upper #bounds for you CI that you calculated (using your function calculate_CI()).

rain_df <- joined %>%
  group_by(city_name, year) %>%
  summarise(
    rain_mean = sample_mean(rainfall),
    rain_sd = sample_sd(rainfall),
    lower_bound = calculate_CI(rainfall,0.95)[1],
    upper_bound = calculate_CI(rainfall,0.95)[2]
  )



rain_df
```



```{r 4B}



#Using the rain_df, plots the estimates of mean rainfall and the 95% confidence intervals on the same plot. There should be a separate faceted plot for each city. Think about using ggplot() with both geom_point() (and geom_line() to connect the points) for the means and geom_errorbar() for the lower and upper bounds of the confidence interval. Check https://r-graphics.org/recipe-annotate-error-bar and or the official documentation https://ggplot2.tidyverse.org/reference/geom_linerange.html for examples of how to use geom_errorbar().


rain_df %>%
  ggplot(aes(x = year, y = rain_mean)) +
  geom_point(size = 3, color = "#2C3E50") +
  geom_path(color = "#3498DB", size = 0.6) +
  geom_errorbar(aes(ymin = lower_bound, ymax = upper_bound), width = 0.2, color = "#E74C3C", size = 0.8) +
  facet_wrap(~ city_name, ncol = 2) +
  labs(
    x = "Year", 
    y = "Rain Mean, (mm)", 
    title = "Yearly Mean Rainfall by City", 
    caption = today(),
    subtitle  = "Sydney sure is dry"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust=0.5, colour = "darkgrey"),
    strip.text = element_text(face = "bold", size = 8),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )


```







